# Chương 2: 
## Giá trị & Kiểu
- JS có kiểu của giá trị, không có kiểu của biến. Các kiểu của biến bao gồm
	+ String : chuỗi
	+ number : số
	+ boolean : true false
	+ null and undefined:
	+ object
	+ symbol (new to ES6).
- Để kiểm tra giá trị và biết kiểu của nó. Ta dùng *typeof*
	```
    var a;
    typeof a;				// "undefined"
    a = "hello world";
    typeof a;				// "string"
    a = 42;
    typeof a;				// "number"
    a = true;
    typeof a;				// "boolean"
    a = null;
    typeof a;				// "object" -- weird, bug
    a = undefined;
    typeof a;				// "undefined"
    a = { b: "c" };
    typeof a;				// "object"
	```
- typeof null là một trường hợp thú vị, bởi vì nó trả sai thành "object", trong khi bạn mong muốn nó trả "null". Đây là 1 lỗi của JS và dường như không bao giờ được sửa vì sửa nó sẽ tạo ra nhiều lỗi hơn

## Objects
- Đề cập đến một giá trị phức hợp mà bạn có thể lập các thuộc tính, mỗi cái đều có thể có giá trị của riêng chúng với bất kỳ kiểu nào.
- Một đối tượng (một object) là một danh sách các item, mỗi item là một cặp name-value, trong đó value có thể là: các kiểu dữ liệu cơ bản, function, hay cũng có thể là một object khác (kiểu dữ liệu phức hợp).
- Ta gọi mỗi item là một property(thuộc tính) của object nếu value của item đó có kiểu dữ liệu là kiểu phức hợp hoặc các kiểu dữ liệu cơ bản, ngược lại nếu value của item nó là một hàm (một function) thì ta gọi nó là method của object (phương thức của object).
- Những cách để truy cập tới thuộc tính của obj: dùng dấu . hoặc dấu ngoặc vuông []
- Cách để tạo ra 1 obj:
	+ Dùng obj literals: dùng cặp ngoặc nhón {} để tạo ra 1 obj. 
		```
        var myBook = {10: 'test1'};  //đối tượng có 1 thuộc tính
        
        //đối tượng có 1 thuộc tính và 1 phương thức (method)
        var myCar = {
           brand: 'Toyota',
           run: function(){
              console.log('running');
           }
        };
		```
	+ Dùng obj constructor: Cách này sẽ sử dụng phương thức khởi tạo (constructor) của kiểu dữ liệu Object để tạo ra các object. Phương thức khởi tạo này là một hàm để tạo ra các object mới, ta dùng kèm từ khoá new:
		```
        //Tạo 1 đối tượng mới
        var myApple = new Object();
        
        //Thêm các thuộc tính cho đối tượng
        myApple.color = 'red';
        myApple.shape = 'round';
        myApple.howSweet = function(){
           console.log('I am sweet');
        };
		```
        ```
        var obj = {
        	a: "hello world",
        	b: 42,
        	c: true
        };
        obj.a;		// "hello world"
        obj.b;		// 42
        obj.c;		// true
        obj["a"];	// "hello world"
        obj["b"];	// 42
        obj["c"];	// true
        ```

## Mảng
- Là đối tượng toàn cục được dùng để xây dựng nên các mảng; là những đối tượng cấp cao và giống một dạng danh sách.
- Khai báo mảng: 
	+ dùng dấu *[]*
		```
			var arr = [value1, value2, ..., valuen];
		```
	+ dùng bằng new Array()
		```
			var arr = new Array(value1, value2, ..., valuen);
		```
- Truy xuất mảng: sử dụng cú pháp *arr[index]* trong đó *arr* là tên mảng, *index* là vị trí mảng
- Các hàm xử lý mảng đã đc js tích hợp
	+ Length: trả về sổ phần tử trong mảng
	+ Join: gộp các phần tử có trong mảng thành chuỗi
	+ ValueOf: nối các phần tử trong mảng bằng dấu ,
	+ Push: thêm phần tử vào mảng
	+ Pop: xóa phần tử cuối cùng của mảng
	+ Unshift: thêm 1 hoặc nhiều phần tử vào đầu mảng
	+ Shift: xóa phần tử đầu tiên của mảng
	+ splice: thêm phần tử vào mảng theo vị trí xác định
	+ concat: ghép 2 mảng với nhau
	+ slice: lấy ra một số phần tử của mảng
	+ sort: sắp xếp lại mảng theo chỉ số chiều tăng dần,  nếu là số thì từ bé đến lớn, chữ thì sắp xếp theo alpha(a-z).
	+ reverse: Hàm này có tác dụng đảo ngược vị trí các phần tử của mảng.
## So sánh các giả trị
- Có hai kiểu so sánh giá trị chính: bằng nhau và không bằng nhau. Kết qủa bất kì của sự so sánh này đều là boolean (true or false).
- Sự ép buộc :
	- Xuất hiện trong 2 dạng của js: *Minh bạch* và *Tiềm ẩn*.
	+ Sự ép buộc minh bạch đơn giản là bạn thấy rõ ràng trong code có sự chuyển đổi từ dạng này sang dạng khác.
        ```
        var a = "42";
        var b = Number( a );
        a;				// "42"
        b;				// 42 -- số!
        ```
	+ Sự ép buộc tiểm ẩn  là khi chuyển đổi dạng có thể xảy ra nhiều hơn, là một hiệu ứng phụ của một số hoạt động khác.
    ```
    var a = "42";
    var b = a * 1;	// "42" ép buộc ngầm 42 tại đây
    a;				// "42"
    b;				// 42 -- số!
    ```

- Đẳng thức: có 4 loại đẳng thức ==; ===; !=; != =
	- Sự khác nhau giữa == vs === đặc trưng rằng == kiểm tra băng nhau của giá trị và === kiểm tra bằng nhau cả giá trị lẫn kiểu giá trị hay có thể nói == cho phép ép cưỡng bức còn === k cho phép ép cưỡng bức
	- Nguyên tắc cơ bản để biết khi nào dùng == và dùng ===
		+ Nếu một trong hai bên trong phép so sánh là có thể là giá trị true hoặc false, tránh dùng == mà dùng ===.
		+ Nếu một trong hai bên trong phép so sánh là có thể một giá trị cụ thể (0, "", hoặc [] -- array rỗng), tránh ==mà dùng ===.
		+ Trong tất cả các trường hợp khác, bạn yên tâm dùng ==. Không chỉ vì nó an toàn, đơn giản là giúp code của bạn dễ đọc hơn trong nhiều trường hợp.
	- Tương tự != và !== cũng vậy. Tất cả các quy tắc cũng đều áp dụng cho so sánh k bằng này.
- Bất đẳng thức: Toán tử <, >, <=, và >= 
	+ Trong JS *string* cũng có thể được so sánh bất bình đẳng, sử dụng nguyên tắc alphabe ("bar" < "foo")
	+ Về sự ép buộc: giống như nguyên tắc so sánh ==, và k có toán tử *bất bình đẳng nghiêm ngặt* như ===
        ```
        var a = 41;
        var b = "42";
        var c = "43";
        a < b;		// true
        b < c;		// true
        ```
	- Nếu cả hai giá trị trong so sánh < đều là string, như ví dụ b < c trên, việc so sánh được thực hiện bằng từ điển học.
	- Nhưng nếu một trong hai giá trị không phải là string, như so sánh a < b, thì cả hai giá trị bị ép thành number, và phép so sánh số thông thường diễn ra.
        ```
        var a = 42;
        var b = "foo";
        a < b;		// false
        a > b;		// false
        a == b;		// false
        ```
	- Có thể so sánh vs nhiều kiểu giá trị khác nhau khi một trong các giá trị k phải là một giá trị số hợp lệ.
	- Đoạn code trên: kết quả ra false vì giá trị *b* bị ép thành 1 giá trị number không hợp lệ là *NaN* trong < và >
